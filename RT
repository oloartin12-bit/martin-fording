require('dotenv').config();
const { Client, GatewayIntentBits, Partials, PermissionsBitField } = require('discord.js');
const fs = require('fs');
const path = require('path');

const PREFIX = process.env.PREFIX || '.';
const OWNER_ID = process.env.OWNER_ID || '';
const TOKEN = process.env.DISCORD_TOKEN;
if (!TOKEN) {
  console.error('‚ö† DISCORD_TOKEN missing in environment variables');
  process.exit(1);
}

// Allow configuring the data file path via env (useful when attaching a persistent disk on Render)
const DATA_PATH = process.env.DATA_PATH || path.join(__dirname, 'data.json');
let db = {};

// Fonction pour charger la base de donn√©es (tol√©rante aux erreurs)
function loadDB() {
  try {
    if (!fs.existsSync(DATA_PATH)) {
      fs.mkdirSync(path.dirname(DATA_PATH), { recursive: true });
      fs.writeFileSync(DATA_PATH, JSON.stringify({
        blacklist: [],
        whitelist: [],
        autoreplies: {},
        settings: { antispam: false, filterlinks: false, autorespond: false, floodprotect: false },
        logs: []
      }, null, 2));
    }
    const raw = fs.readFileSync(DATA_PATH, 'utf8');
    db = JSON.parse(raw || '{}');

    // garantir la structure minimale
    db.blacklist = Array.isArray(db.blacklist) ? db.blacklist : [];
    db.whitelist = Array.isArray(db.whitelist) ? db.whitelist : [];
    db.autoreplies = db.autoreplies && typeof db.autoreplies === 'object' ? db.autoreplies : {};
    db.settings = db.settings && typeof db.settings === 'object' ? Object.assign({ antispam: false, filterlinks: false, autorespond: false, floodprotect: false }, db.settings) : { antispam: false, filterlinks: false, autorespond: false, floodprotect: false };
    db.logs = Array.isArray(db.logs) ? db.logs : [];
  } catch (err) {
    console.error('Erreur lors du chargement de data.json, recr√©ation d‚Äôun fichier propre', err);
    db = {
      blacklist: [],
      whitelist: [],
      autoreplies: {},
      settings: { antispam: false, filterlinks: false, autorespond: false, floodprotect: false },
      logs: []
    };
    try { fs.writeFileSync(DATA_PATH, JSON.stringify(db, null, 2)); } catch (e) { console.error('Impossible d‚Äô√©crire data.json', e); }
  }
}

// Fonction pour sauvegarder la base de donn√©es (√©criture simple)
function saveDB() {
  try {
    fs.writeFileSync(DATA_PATH, JSON.stringify(db, null, 2));
  } catch (err) {
    console.error('Erreur lors de la sauvegarde de data.json', err);
  }
}

// Fonction pour journaliser un √©v√©nement
function logEvent(evt) {
  try {
    const entry = { ts: new Date().toISOString(), evt };
    db.logs.unshift(entry);
    if (db.logs.length > 200) db.logs.length = 200;
    saveDB();
  } catch (err) {
    console.error('Erreur lors du logEvent', err);
  }
}

// Utilitaire pour d√©tecter les liens
function isLink(text) {
  return /(https?:\/\/|www\.)/i.test(text);
}

const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent],
  partials: [Partials.Channel]
});

loadDB();

client.once('ready', () => {
  console.log(`‚úÖ Nissi V2 DMF connect√© en tant que ${client.user?.tag || 'unknown'}`);
});

// Gestion d'erreurs/garde-fous
client.on('error', err => console.error('Discord client error:', err));
client.on('shardError', err => console.error('Shard error:', err));
client.on('warn', info => console.warn('Discord client warn:', info));

// Cooldown/protection anti-flood
const lastMessage = new Map();

client.on('messageCreate', async message => {
  try {
    if (!message || !message.author) return;
    if (message.author.bot) return;

    // Filtres globaux
    const s = db.settings || {};
    const isWhitelisted = Array.isArray(db.whitelist) && db.whitelist.includes(message.author.id);
    const isBlacklisted = Array.isArray(db.blacklist) && db.blacklist.includes(message.author.id);
    
    if (isBlacklisted) return;

    // Filtrer les liens
    if (s.filterlinks && isLink(message.content || '') && !isWhitelisted) {
      await message.delete().catch(() => {});
      logEvent(`Lien supprim√© de ${message.author.tag} dans #${message.channel?.name || message.channel?.id || 'unknown'}`);
      return;
    }

    // Protection anti-flood simple
    if (s.floodprotect && !isWhitelisted) {
      const key = `${message.guild?.id || 'dm'}:${message.author.id}`;
      const now = Date.now();
      const prev = lastMessage.get(key) || 0;
      if (now - prev < 800) {
        await message.delete().catch(() => {});
        logEvent(`Flood supprim√© de ${message.author.tag}`);
        return;
      }
      lastMessage.set(key, now);
    }

    // R√©ponse automatique
    if (s.autorespond) {
      for (const trigger in db.autoreplies) {
        if ((message.content || '').toLowerCase().includes(trigger.toLowerCase())) {
          await message.channel.send(db.autoreplies[trigger]).catch(() => {});
          logEvent(`Auto-r√©ponse "${trigger}" -> "${db.autoreplies[trigger]}" pour ${message.author.tag}`);
          break;
        }
      }
    }

    // Gestion des commandes
    if (!message.content || !message.content.startsWith(PREFIX)) return;
    const args = message.content.slice(PREFIX.length).trim().split(/\s+/);
    const cmd = (args.shift() || '').toLowerCase();
    const isOwner = message.author.id === OWNER_ID;
    const isAdmin = message.member?.permissions?.has(PermissionsBitField.Flags.Administrator) || isOwner;

    switch (cmd) {
      case 'help':
      case 'menu': {
        const menu = `üõ° MARTIN FORDING DMF - Menu Commandes S√©curit√© (1 √† 20) üõ°
.help - Voir ce menu
.status - V√©rifier statut du bot
.antispam on/off - Activer/D√©sactiver l‚Äôanti-spam
.block [id] - Bloquer (simul√©) un utilisateur
.unblock [id] - D√©bloquer (simul√©)
.ban [id] - Signaler (simul√©) un utilisateur
.purge [n] - Supprimer n messages (mod only)
.scan [msg] - Scanner message suspect (non impl√©ment√©)
.filterlinks on/off - Filtrer liens dangereux
.log - Journal des menaces (owner only)
.autorespond on/off - R√©ponses automatiques
.setreply [trigger] | [r√©ponse] - D√©finir r√©ponse auto
.delreply [trigger] - Supprimer r√©ponse auto
.listreply - Lister r√©ponses auto
.floodprotect on/off - Anti-flood
.whitelist add [id] - Ajouter num√©ro s√ªr (discord id)
.whitelist remove [id] - Retirer whitelist
.blacklist add [id] - Ajouter blacklist (simul√©)
.blacklist remove [id] - Retirer blacklist
.shutdown - √âteindre le bot (owner only)
üîê Nissi V2 DMF - S√©curit√© & Contr√¥le`;
        message.channel.send(menu).catch(() => {});
        break;
      }

      case 'status': {
        const st = db.settings || {};
        message.channel.send(`Nissi V2 DMF en ligne.\nSettings: antispam=${st.antispam}, filterlinks=${st.filterlinks}, autorespond=${st.autorespond}, floodprotect=${st.floodprotect}`).catch(() => {});
        break;
      }

      case 'antispam': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const param = args[0];
        if (!param || !['on', 'off'].includes(param)) return message.reply('Utilisation : `.antispam on/off`');
        db.settings.antispam = param === 'on';
        saveDB();
        message.reply(`L'anti-spam a √©t√© d√©fini sur \`${param}\`.`);
        logEvent(`antispam ${param} par ${message.author.tag}`);
        break;
      }

      case 'filterlinks': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const p = args[0];
        if (!p || !['on', 'off'].includes(p)) return message.reply('Utilisation : `.filterlinks on/off`');
        db.settings.filterlinks = p === 'on';
        saveDB();
        message.reply(`Le filtrage des liens a √©t√© d√©fini sur \`${p}\`.`);
        logEvent(`filterlinks ${p}`);
        break;
      }

      case 'autorespond': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const p = args[0];
        if (!p || !['on', 'off'].includes(p)) return message.reply('Utilisation : `.autorespond on/off`');
        db.settings.autorespond = p === 'on';
        saveDB();
        message.reply(`L'auto-r√©ponse a √©t√© d√©finie sur \`${p}\`.`);
        logEvent(`autorespond ${p}`);
        break;
      }

      case 'setreply': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const raw = message.content.slice((PREFIX + 'setreply').length).trim();
        const parts = raw.split('|').map(s => s.trim());
        if (parts.length < 2) return message.reply('Utilisation : `.setreply trigger | r√©ponse`');
        const trigger = parts[0].toLowerCase();
        const resp = parts.slice(1).join(' | ');
        db.autoreplies[trigger] = resp;
        saveDB();
        message.reply(`R√©ponse automatique ajout√©e pour : **"${trigger}"**`);
        logEvent(`setreply "${trigger}" -> "${resp}"`);
        break;
      }

      case 'delreply': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const t = args.join(' ').toLowerCase();
        if (!t) return message.reply('Utilisation : `.delreply trigger`');
        if (db.autoreplies[t]) {
          delete db.autoreplies[t];
          saveDB();
          message.reply(`R√©ponse automatique supprim√©e : **"${t}"**`);
          logEvent(`delreply "${t}"`);
        } else message.reply('Trigger non trouv√©.');
        break;
      }

      case 'listreply': {
        const keys = Object.keys(db.autoreplies);
        if (!keys.length) return message.reply('Aucune r√©ponse automatique d√©finie.');
        const lines = keys.map(k => `‚Ä¢ **${k}** => ${db.autoreplies[k]}`).join('\n');
        message.channel.send(`R√©ponses automatiques :\n${lines}`).catch(() => {});
        break;
      }

      case 'block': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const id = args[0];
        if (!id) return message.reply('Utilisation : `.block [userId]`');
        if (!db.blacklist.includes(id)) {
          db.blacklist.push(id);
          saveDB();
          message.reply(`ID **${id}** ajout√© √† la blacklist (simulation).`);
          logEvent(`blocked (simul√©) ${id} par ${message.author.tag}`);
        } else message.reply('D√©j√† en blacklist.');
        break;
      }

      case 'unblock': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const idu = args[0];
        if (!idu) return message.reply('Utilisation : `.unblock [userId]`');
        const idx = db.blacklist.indexOf(idu);
        if (idx !== -1) {
          db.blacklist.splice(idx, 1);
          saveDB();
          message.reply(`ID **${idu}** retir√© de la blacklist.`);
          logEvent(`unblocked ${idu}`);
        } else message.reply('ID non trouv√© en blacklist.');
        break;
      }

      case 'ban': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const idb = args[0];
        if (!idb) return message.reply('Utilisation : `.ban [userId]` (simulation de signalement)');
        logEvent(`reported (simul√©) ${idb} par ${message.author.tag}`);
        message.reply(`Signalement simul√© pour **${idb}**. (Le bot n'ex√©cute pas de signalement automatique r√©el.)`);
        break;
      }

      case 'purge': {
        if (!message.member?.permissions?.has(PermissionsBitField.Flags.ManageMessages)) {
          return message.reply('Permission requise : `ManageMessages`.');
        }

        if (!message.guild || !message.channel.isTextBased()) {
          return message.reply("Cette commande ne peut √™tre utilis√©e que dans un salon textuel de serveur.");
        }

        const n = parseInt(args[0]);
        if (isNaN(n) || n < 1 || n > 100) {
          return message.reply('Veuillez fournir un nombre valide entre 1 et 100.');
        }

        try {
          const fetched = await message.channel.bulkDelete(n, true);
          const confirmationMsg = await message.channel.send(`Supprim√© **${fetched.size}** messages.`);
          setTimeout(() => confirmationMsg.delete().catch(() => {}), 5000);
          logEvent(`Purge de ${fetched.size} messages par ${message.author.tag} dans #${message.channel?.name || 'unknown'}`);
        } catch (e) {
          if (e.code === 50034) {
            const errorMsg = await message.reply("Erreur : Impossible de supprimer les messages datant de plus de 14 jours via la purge en masse.");
            setTimeout(() => errorMsg.delete().catch(() => {}), 5000);
          } else {
            console.error(e);
            message.reply(`Une erreur est survenue lors de la purge : \`${e.message}\`.`);
          }
        }
        break;
      }

      case 'floodprotect': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const p = args[0];
        if (!p || !['on', 'off'].includes(p)) return message.reply('Utilisation : `.floodprotect on/off`');
        db.settings.floodprotect = p === 'on';
        saveDB();
        message.reply(`La protection anti-flood a √©t√© d√©finie sur \`${p}\`.`);
        logEvent(`floodprotect ${p}`);
        break;
      }

      case 'whitelist': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const [action, id] = args;
        if (!['add', 'remove'].includes(action) || !id) return message.reply('Utilisation : `.whitelist add/remove [userId]`');
        if (action === 'add') {
          if (!db.whitelist.includes(id)) {
            db.whitelist.push(id);
            saveDB();
            message.reply(`ID **${id}** ajout√© √† la whitelist.`);
            logEvent(`whitelist add ${id}`);
          } else message.reply('ID d√©j√† en whitelist.');
        } else if (action === 'remove') {
          const idx = db.whitelist.indexOf(id);
          if (idx !== -1) {
            db.whitelist.splice(idx, 1);
            saveDB();
            message.reply(`ID **${id}** retir√© de la whitelist.`);
            logEvent(`whitelist remove ${id}`);
          } else message.reply('ID non trouv√© en whitelist.');
        }
        break;
      }

      case 'blacklist': {
        if (!isAdmin) return message.reply('Permission requise : Administrateur.');
        const [action, id] = args;
        if (!['add', 'remove'].includes(action) || !id) return message.reply('Utilisation : `.blacklist add/remove [userId]`');
        if (action === 'add') {
          if (!db.blacklist.includes(id)) {
            db.blacklist.push(id);
            saveDB();
            message.reply(`ID **${id}** ajout√© √† la blacklist (simulation).`);
            logEvent(`blacklist add (simul√©) ${id}`);
          } else message.reply('ID d√©j√† en blacklist.');
        } else if (action === 'remove') {
          const idx = db.blacklist.indexOf(id);
          if (idx !== -1) {
            db.blacklist.splice(idx, 1);
            saveDB();
            message.reply(`ID **${id}** retir√© de la blacklist.`);
            logEvent(`blacklist remove ${id}`);
          } else message.reply('ID non trouv√© en blacklist.');
        }
        break;
      }

      case 'log': {
        if (!isOwner) return message.reply('Seul le propri√©taire peut utiliser cette commande.');
        if (!db.logs.length) return message.reply('Aucun √©v√©nement enregistr√©.');
        const logsText = db.logs.map(log => `[${log.ts}] ${log.evt}`).join('\n');
        message.channel.send(`Journal des √©v√©nements :\n\`\`\`${logsText}\`\`\``).catch(() => {});
        break;
      }

      case 'shutdown': {
        if (!isOwner) return message.reply('Seul le propri√©taire peut √©teindre le bot.');
        message.reply('Extinction en cours...').then(() => {
          shutdownAndExit(0);
        }).catch(() => { shutdownAndExit(0); });
        break;
      }

      default:
        break;
    }
  } catch (err) {
    console.error('Erreur dans messageCreate handler', err);
  }
});

// Graceful shutdown helper
function shutdownAndExit(code = 0) {
  try {
    saveDB();
  } catch (e) {
    console.error('Erreur lors de la sauvegarde finale', e);
  }
  try {
    if (client) client.destroy();
  } catch (e) {
    console.error('Erreur lors de la destruction du client', e);
  }
  process.exit(code);
}

process.on('SIGINT', () => {
  console.log('SIGINT re√ßu : sauvegarde et arr√™t');
  shutdownAndExit(0);
});
process.on('SIGTERM', () => {
  console.log('SIGTERM re√ßu : sauvegarde et arr√™t');
  shutdownAndExit(0);
});
process.on('uncaughtException', (err) => {
  console.error('uncaughtException:', err);
  shutdownAndExit(1);
});
process.on('unhandledRejection', (reason) => {
  console.error('unhandledRejection:', reason);
});

client.login(TOKEN).catch(err => {
  console.error('√âchec de connexion au client Discord:', err);
  process.exit(1);
});
